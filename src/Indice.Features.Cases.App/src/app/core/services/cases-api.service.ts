//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const CASES_API_BASE_URL = new InjectionToken<string>('CASES_API_BASE_URL');

export interface ICasesApiService {
    /**
     * Download attachment in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Create a new case in draft mode.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string>;
    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerId (optional) 
     * @param filter_CustomerName (optional) 
     * @param filter_From (optional) 
     * @param filter_To (optional) 
     * @param filter_CaseTypeCodes (optional) 
     * @param filter_CheckpointTypeCodes (optional) 
     * @param filter_GroupIds (optional) 
     * @param filter_Metadata (optional) construct filter clauses based on the metadata you are adding to the cases in your installation
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    getCases(filter_CustomerId?: string | undefined, filter_CustomerName?: string | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet>;
    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails>;
    /**
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void>;
    /**
     * Download case in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions>;
    /**
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void>;
    /**
     * @param api_version (optional) 
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param data (optional) The data of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitAdminCase(caseId: string, data?: string | undefined, api_version?: string | undefined): Observable<void>;
    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]>;
    /**
     * Get case types
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes(api_version?: string | undefined): Observable<CaseType[]>;
    /**
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param taxId (optional) The tax identification of the customer.
     * @param api_version (optional) 
     * @return Success
     */
    getCustomers(customerId?: string | undefined, taxId?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]>;
    createCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getCases2(page?: number | undefined, pageSize?: number | undefined, sort?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet>;
    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse>;
    /**
     * Get case by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<MyCasePartial>;
    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink>;
    /**
     * Download case in a PDF format
     * @param api_version (optional) 
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Gets a case type
     * @param api_version (optional) 
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseType>;
    /**
     * @param api_version (optional) 
     * @return Success
     */
    getEGovKycIdentityCaseImage(caseId: string, api_version?: string | undefined): Observable<CaseImage>;
}

@Injectable({
    providedIn: 'root'
})
export class CasesApiService implements ICasesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CASES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Download attachment in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/attachments/{attachmentId}/download?";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Create a new case in draft mode.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateDraftAdminCase(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerId (optional) 
     * @param filter_CustomerName (optional) 
     * @param filter_From (optional) 
     * @param filter_To (optional) 
     * @param filter_CaseTypeCodes (optional) 
     * @param filter_CheckpointTypeCodes (optional) 
     * @param filter_GroupIds (optional) 
     * @param filter_Metadata (optional) construct filter clauses based on the metadata you are adding to the cases in your installation
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    getCases(filter_CustomerId?: string | undefined, filter_CustomerName?: string | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (filter_CustomerId === null)
            throw new Error("The parameter 'filter_CustomerId' cannot be null.");
        else if (filter_CustomerId !== undefined)
            url_ += "Filter.CustomerId=" + encodeURIComponent("" + filter_CustomerId) + "&";
        if (filter_CustomerName === null)
            throw new Error("The parameter 'filter_CustomerName' cannot be null.");
        else if (filter_CustomerName !== undefined)
            url_ += "Filter.CustomerName=" + encodeURIComponent("" + filter_CustomerName) + "&";
        if (filter_From === null)
            throw new Error("The parameter 'filter_From' cannot be null.");
        else if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toISOString() : "") + "&";
        if (filter_To === null)
            throw new Error("The parameter 'filter_To' cannot be null.");
        else if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toISOString() : "") + "&";
        if (filter_CaseTypeCodes === null)
            throw new Error("The parameter 'filter_CaseTypeCodes' cannot be null.");
        else if (filter_CaseTypeCodes !== undefined)
            filter_CaseTypeCodes && filter_CaseTypeCodes.forEach(item => { url_ += "Filter.CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CheckpointTypeCodes === null)
            throw new Error("The parameter 'filter_CheckpointTypeCodes' cannot be null.");
        else if (filter_CheckpointTypeCodes !== undefined)
            filter_CheckpointTypeCodes && filter_CheckpointTypeCodes.forEach(item => { url_ += "Filter.CheckpointTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_GroupIds === null)
            throw new Error("The parameter 'filter_GroupIds' cannot be null.");
        else if (filter_GroupIds !== undefined)
            filter_GroupIds && filter_GroupIds.forEach(item => { url_ += "Filter.GroupIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Metadata === null)
            throw new Error("The parameter 'filter_Metadata' cannot be null.");
        else if (filter_Metadata !== undefined)
            filter_Metadata && filter_Metadata.forEach(item => { url_ += "Filter.Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasePartialResultSet>;
        }));
    }

    protected processGetCases(response: HttpResponseBase): Observable<CasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasePartialResultSet>(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseDetails>;
        }));
    }

    protected processGetCaseById(response: HttpResponseBase): Observable<CaseDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseDetails>(null as any);
    }

    /**
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Download case in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}.pdf?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/actions?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseActions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseActions>;
        }));
    }

    protected processGetCaseActions(response: HttpResponseBase): Observable<CaseActions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseActions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseActions>(null as any);
    }

    /**
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/approve?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitApproval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param api_version (optional) 
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/assign?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAdminCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAdminCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadAdminCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasesAttachmentLink>(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param data (optional) The data of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitAdminCase(caseId: string, data?: string | undefined, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (data === null)
            throw new Error("The parameter 'data' cannot be null.");
        else if (data !== undefined)
            url_ += "data=" + encodeURIComponent("" + data) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/timeline?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTimeline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTimeline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimelineEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimelineEntry[]>;
        }));
    }

    protected processGetCaseTimeline(response: HttpResponseBase): Observable<TimelineEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimelineEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimelineEntry[]>(null as any);
    }

    /**
     * Get case types
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes(api_version?: string | undefined): Observable<CaseType[]> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType[]>;
        }));
    }

    protected processGetCaseTypes(response: HttpResponseBase): Observable<CaseType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CaseType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseType[]>(null as any);
    }

    /**
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param taxId (optional) The tax identification of the customer.
     * @param api_version (optional) 
     * @return Success
     */
    getCustomers(customerId?: string | undefined, taxId?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]> {
        let url_ = this.baseUrl + "/api/manage/integrations/customers?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (taxId === null)
            throw new Error("The parameter 'taxId' cannot be null.");
        else if (taxId !== undefined)
            url_ += "TaxId=" + encodeURIComponent("" + taxId) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDetails[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDetails[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDetails[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDetails[]>(null as any);
    }

    createCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/users/subscriptions?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCaseTypeNotificationSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCaseTypeNotificationSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCaseTypeNotificationSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sort (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getCases2(page?: number | undefined, pageSize?: number | undefined, sort?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCases2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCases2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyCasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyCasePartialResultSet>;
        }));
    }

    protected processGetCases2(response: HttpResponseBase): Observable<MyCasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyCasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MyCasePartialResultSet>(null as any);
    }

    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCaseResponse>;
        }));
    }

    protected processCreateDraftCase(response: HttpResponseBase): Observable<CreateCaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCaseResponse>(null as any);
    }

    /**
     * Get case by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<MyCasePartial> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyCasePartial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyCasePartial>;
        }));
    }

    protected processGetMyCaseById(response: HttpResponseBase): Observable<MyCasePartial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyCasePartial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MyCasePartial>(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasesAttachmentLink>(null as any);
    }

    /**
     * Download case in a PDF format
     * @param api_version (optional) 
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/download?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMyCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMyCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadMyCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMyCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMyCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitMyCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets a case type
     * @param api_version (optional) 
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseType> {
        let url_ = this.baseUrl + "/api/my/case-types/{caseTypeCode}?";
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType>;
        }));
    }

    protected processGetCaseType(response: HttpResponseBase): Observable<CaseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseType>(null as any);
    }

    /**
     * @param api_version (optional) 
     * @return Success
     */
    getEGovKycIdentityCaseImage(caseId: string, api_version?: string | undefined): Observable<CaseImage> {
        let url_ = this.baseUrl + "/case-details/{caseId}/e-gov-kyc-identity-image?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEGovKycIdentityCaseImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEGovKycIdentityCaseImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseImage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseImage>;
        }));
    }

    protected processGetEGovKycIdentityCaseImage(response: HttpResponseBase): Observable<CaseImage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseImage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseImage>(null as any);
    }
}

/** The Approval action for a Case. */
export enum Approval {
    Approve = "Approve",
    Reject = "Reject",
}

export class ApprovalRequest implements IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;

    constructor(data?: IApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;
}

/** Audit metadata related with the user principal that "did" the action. */
export class AuditMeta implements IAuditMeta {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    when?: Date | undefined;

    constructor(data?: IAuditMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.when = _data["when"] ? new Date(_data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditMeta {
        data = typeof data === 'object' ? data : {};
        let result = new AuditMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data;
    }
}

/** Audit metadata related with the user principal that "did" the action. */
export interface IAuditMeta {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    when?: Date | undefined;
}

export class CaseActions implements ICaseActions {
    hasAssignment?: boolean;
    hasUnassignment?: boolean;
    hasEdit?: boolean;
    hasApproval?: boolean;

    constructor(data?: ICaseActions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasAssignment = _data["hasAssignment"];
            this.hasUnassignment = _data["hasUnassignment"];
            this.hasEdit = _data["hasEdit"];
            this.hasApproval = _data["hasApproval"];
        }
    }

    static fromJS(data: any): CaseActions {
        data = typeof data === 'object' ? data : {};
        let result = new CaseActions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasAssignment"] = this.hasAssignment;
        data["hasUnassignment"] = this.hasUnassignment;
        data["hasEdit"] = this.hasEdit;
        data["hasApproval"] = this.hasApproval;
        return data;
    }
}

export interface ICaseActions {
    hasAssignment?: boolean;
    hasUnassignment?: boolean;
    hasEdit?: boolean;
    hasApproval?: boolean;
}

/** Minimal Case Attachment response model. */
export class CaseAttachment implements ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;

    constructor(data?: ICaseAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CaseAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        data["data"] = this.data;
        return data;
    }
}

/** Minimal Case Attachment response model. */
export interface ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;
}

/** Models case details. */
export class CaseDetails implements ICaseDetails {
    id?: string;
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    customerId?: string | undefined;
    userId?: string | undefined;
    customerName?: string | undefined;
    createdByWhen?: Date | undefined;
    caseType?: CaseType;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointTypeCode?: string | undefined;
    data?: string | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    attachments?: CaseAttachment[] | undefined;

    constructor(data?: ICaseDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.publicStatus = _data["publicStatus"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.caseType = _data["caseType"] ? CaseType.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(CaseAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CaseDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["publicStatus"] = this.publicStatus;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

/** Models case details. */
export interface ICaseDetails {
    id?: string;
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    customerId?: string | undefined;
    userId?: string | undefined;
    customerName?: string | undefined;
    createdByWhen?: Date | undefined;
    caseType?: CaseType;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointTypeCode?: string | undefined;
    data?: string | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    attachments?: CaseAttachment[] | undefined;
}

export class CaseImage implements ICaseImage {
    data?: string | undefined;
    mimeType?: string | undefined;

    constructor(data?: ICaseImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.mimeType = _data["mimeType"];
        }
    }

    static fromJS(data: any): CaseImage {
        data = typeof data === 'object' ? data : {};
        let result = new CaseImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["mimeType"] = this.mimeType;
        return data;
    }
}

export interface ICaseImage {
    data?: string | undefined;
    mimeType?: string | undefined;
}

export class CasePartial implements ICasePartial {
    id?: string;
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    customerId?: string | undefined;
    userId?: string | undefined;
    customerName?: string | undefined;
    createdByWhen?: Date | undefined;
    caseType?: CaseType;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointTypeCode?: string | undefined;
    data?: string | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;

    constructor(data?: ICasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.publicStatus = _data["publicStatus"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.caseType = _data["caseType"] ? CaseType.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
        }
    }

    static fromJS(data: any): CasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["publicStatus"] = this.publicStatus;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        return data;
    }
}

export interface ICasePartial {
    id?: string;
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    customerId?: string | undefined;
    userId?: string | undefined;
    customerName?: string | undefined;
    createdByWhen?: Date | undefined;
    caseType?: CaseType;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointTypeCode?: string | undefined;
    data?: string | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
}

export class CasePartialResultSet implements ICasePartialResultSet {
    count?: number;
    items?: CasePartial[] | undefined;

    constructor(data?: ICasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICasePartialResultSet {
    count?: number;
    items?: CasePartial[] | undefined;
}

/** Define the status for the customer. It is defined at the Indice.AspNetCore.Features.Cases.Data.Models.DbCheckpointType.PublicStatus. */
export enum CasePublicStatus {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Completed = "Completed",
    Deleted = "Deleted",
}

export class CaseType implements ICaseType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    dataSchema?: string | undefined;
    layout?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;

    constructor(data?: ICaseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): CaseType {
        data = typeof data === 'object' ? data : {};
        let result = new CaseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ICaseType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    dataSchema?: string | undefined;
    layout?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
}

export class CaseTypeTranslation implements ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;

    constructor(data?: ICaseTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CaseTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;
}

/** Models an attachment that is associated with a campaign. */
export class CasesAttachmentLink implements ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    readonly sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;

    constructor(data?: ICasesAttachmentLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileGuid = _data["fileGuid"];
            this.permaLink = _data["permaLink"];
            this.label = _data["label"];
            this.size = _data["size"];
            (<any>this).sizeText = _data["sizeText"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): CasesAttachmentLink {
        data = typeof data === 'object' ? data : {};
        let result = new CasesAttachmentLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileGuid"] = this.fileGuid;
        data["permaLink"] = this.permaLink;
        data["label"] = this.label;
        data["size"] = this.size;
        data["sizeText"] = this.sizeText;
        data["contentType"] = this.contentType;
        return data;
    }
}

/** Models an attachment that is associated with a campaign. */
export interface ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;
}

/** The checkpoint entry for a case. */
export class Checkpoint implements ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    /** The checkpoint type code. This is the inner status the back-officer can see. */
    checkpointTypeCode?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** Indicates if the checkpoint is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;

    constructor(data?: ICheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.publicStatus = _data["publicStatus"];
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.private = _data["private"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Checkpoint {
        data = typeof data === 'object' ? data : {};
        let result = new Checkpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["publicStatus"] = this.publicStatus;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["private"] = this.private;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        return data;
    }
}

/** The checkpoint entry for a case. */
export interface ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    /** The checkpoint type code. This is the inner status the back-officer can see. */
    checkpointTypeCode?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** Indicates if the checkpoint is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;
}

/** The comment entry for a case. */
export class Comment implements IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.isCustomer = _data["isCustomer"];
            this.private = _data["private"];
            this.attachment = _data["attachment"] ? CasesAttachmentLink.fromJS(_data["attachment"]) : <any>undefined;
            this.replyToComment = _data["replyToComment"] ? Comment.fromJS(_data["replyToComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["isCustomer"] = this.isCustomer;
        data["private"] = this.private;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["replyToComment"] = this.replyToComment ? this.replyToComment.toJSON() : <any>undefined;
        return data;
    }
}

/** The comment entry for a case. */
export interface IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;
}

export class CreateCaseResponse implements ICreateCaseResponse {
    id?: string;
    created?: Date;

    constructor(data?: ICreateCaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateCaseResponse {
    id?: string;
    created?: Date;
}

export class CreateDraftCaseRequest implements ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;

    constructor(data?: ICreateDraftCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeCode = _data["caseTypeCode"];
            this.groupId = _data["groupId"];
            this.customer = _data["customer"] ? CustomerMeta.fromJS(_data["customer"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CreateDraftCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDraftCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeCode"] = this.caseTypeCode;
        data["groupId"] = this.groupId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["channel"] = this.channel;
        return data;
    }
}

export interface ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.AspNetCore.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export class CustomerDetails implements ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: ICustomerDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.groupId = _data["groupId"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomerDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["groupId"] = this.groupId;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.AspNetCore.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export interface ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export class CustomerMeta implements ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    readonly fullName?: string | undefined;

    constructor(data?: ICustomerMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): CustomerMeta {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        return data;
    }
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export interface ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
}

export class EditCaseRequest implements IEditCaseRequest {
    data?: string | undefined;

    constructor(data?: IEditCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): EditCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

export interface IEditCaseRequest {
    data?: string | undefined;
}

/** The model for the customer with the minimum required properties. */
export class MyCasePartial implements IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The date the case was created. */
    created?: Date | undefined;
    publicStatus?: CasePublicStatus;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    title?: string | undefined;
    /** The checkpoint name of the case. */
    checkpoint?: string | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;

    constructor(data?: IMyCasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.publicStatus = _data["publicStatus"];
            this.caseTypeCode = _data["caseTypeCode"];
            this.title = _data["title"];
            this.checkpoint = _data["checkpoint"];
            this.message = _data["message"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? MyCasePartialTranslation.fromJS(_data["translations"][key]) : new MyCasePartialTranslation();
                }
            }
        }
    }

    static fromJS(data: any): MyCasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["publicStatus"] = this.publicStatus;
        data["caseTypeCode"] = this.caseTypeCode;
        data["title"] = this.title;
        data["checkpoint"] = this.checkpoint;
        data["message"] = this.message;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** The model for the customer with the minimum required properties. */
export interface IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The date the case was created. */
    created?: Date | undefined;
    publicStatus?: CasePublicStatus;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    title?: string | undefined;
    /** The checkpoint name of the case. */
    checkpoint?: string | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;
}

export class MyCasePartialResultSet implements IMyCasePartialResultSet {
    count?: number;
    items?: MyCasePartial[] | undefined;

    constructor(data?: IMyCasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MyCasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyCasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMyCasePartialResultSet {
    count?: number;
    items?: MyCasePartial[] | undefined;
}

export class MyCasePartialTranslation implements IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;

    constructor(data?: IMyCasePartialTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): MyCasePartialTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** A class that represents a timeline entry for a case. */
export class TimelineEntry implements ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    readonly isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;

    constructor(data?: ITimelineEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? AuditMeta.fromJS(_data["createdBy"]) : <any>undefined;
            (<any>this).isCheckpoint = _data["isCheckpoint"];
            this.checkpoint = _data["checkpoint"] ? Checkpoint.fromJS(_data["checkpoint"]) : <any>undefined;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimelineEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TimelineEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["isCheckpoint"] = this.isCheckpoint;
        data["checkpoint"] = this.checkpoint ? this.checkpoint.toJSON() : <any>undefined;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data;
    }
}

/** A class that represents a timeline entry for a case. */
export interface ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;
}

export class UpdateCaseRequest implements IUpdateCaseRequest {
    data?: string | undefined;

    constructor(data?: IUpdateCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

export interface IUpdateCaseRequest {
    data?: string | undefined;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>(<any>this).errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}